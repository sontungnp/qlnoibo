'use strict'

// === Chuẩn hoá Unicode
function normalizeUnicode(str) {
  return str ? str.normalize('NFC').toLowerCase().trim() : ''
}

// === HÀM RENDER HEADER + FILTER ROW ===
function addHeaderAndFilterCells(headers, filterSpecBuilder) {
  headers.forEach((h, idx) => {
    // Render header column
    $('#table-header').append(`<th>${h}</th>`)
    // Nếu có cấu hình filter (button/input) thì render vào dòng filter
    const spec = filterSpecBuilder ? filterSpecBuilder(h, idx) : null
    if (spec && spec.type === 'button') {
      $('#table-filters').append(
        `<th><button class="show-filter-btn" data-coltype="${spec.coltype}" data-idx="${spec.idx}">Filter</button></th>`
      )
    } else if (spec && spec.type === 'input') {
      $('#table-filters').append(
        `<th><input type="text" class="column-filter" id="filter-${spec.idx}" placeholder="Filter ${h}" /></th>`
      )
    } else {
      $('#table-filters').append('<th></th>')
    }
  })
}

// === TÍNH TỔNG CHO CÁC CỘT MEASURE (tree view hoặc pivot/flat view) ===
function calculateTotals(
  dataRows,
  measureColumns,
  allColumns,
  isTreeView = false,
  nodeList = []
) {
  const totals = {}

  if (isTreeView && nodeList.length > 0) {
    // Trường hợp tree view → duyệt nodeList, cộng giá trị từ các node lá
    measureColumns.forEach((col, idx) => {
      totals[idx] = 0
      nodeList.forEach((node) => {
        if (node.isLeaf && node.measures[col]) {
          const value =
            parseFloat(node.measures[col].replace(/[^\d.-]/g, '')) || 0
          totals[idx] += value
        }
      })
    })
  }

  return totals
}

// === ADD TOTAL ROW VÀO TABLE ===
function addTotalRow(
  measureColumns,
  totals,
  totalColumns,
  isTreeView = false,
  dimCols = []
) {
  let totalRow =
    '<tr class="total-row" style="font-weight: bold; background-color: #e6e6e6;">'

  if (isTreeView) {
    // Tree view → cột đầu tiên hiển thị "TOTAL", dimCols rỗng, measureCols có tổng
    totalRow += '<td>TOTAL</td>'
    dimCols.forEach(() => {
      totalRow += '<td></td>'
    })
    measureColumns.forEach((col, idx) => {
      totalRow += `<td style="text-align:right">${formatNumber(
        totals[idx]
      )}</td>`
    })
  } else {
    // Flat/pivot view → match theo totalColumns
    totalColumns.forEach((col, idx) => {
      if (measureColumns.includes(col)) {
        const measureIndex = measureColumns.indexOf(col)
        totalRow += `<td style="text-align:right">${formatNumber(
          totals[measureIndex]
        )}</td>`
      } else {
        totalRow += '<td></td>'
      }
    })
  }

  totalRow += '</tr>'
  $('#table-body').append(totalRow)
}

// === Format number với dấu phẩy ngàn ===
function formatNumber(num) {
  if (isNaN(num)) return ''
  return new Intl.NumberFormat().format(num)
}

// === Collapse toàn bộ con cháu của 1 node trong tree ===
function collapseChildren(parentId) {
  $(`tr[data-parent-id="${parentId}"]`).each(function () {
    let childId = $(this).data('node-id')
    $(this).hide().removeClass('expanded')
    $(this).find('.toggle-btn').text('[+]')
    collapseChildren(childId)
  })
}

// === Expand con trực tiếp của node ===
function expandChildren(parentId) {
  $(`tr[data-parent-id="${parentId}"]`).each(function () {
    $(this).show()
  })
}

// === Expand All Nodes ===
function expandAll() {
  // Show tất cả các row
  $('#table-body tr').show().addClass('expanded')
  // Đổi ký hiệu toggle-btn thành [−]
  $('#table-body .toggle-btn').text('[−]')
}

// === Collapse All Nodes ===
function collapseAll() {
  // Ẩn tất cả các row có parent (chỉ để root lại)
  $('#table-body tr[data-parent-id]').hide().removeClass('expanded')
  // Reset toggle-btn về [+]
  $('#table-body .toggle-btn').text('[+]')
}

// === Copy các dòng đang highlight vào clipboard ===
function copySelectedRows() {
  let copiedText = ''
  $('.highlight:not(.total-row)').each(function () {
    let rowData = $(this)
      .find('td')
      .map(function () {
        return $(this).text().trim()
      })
      .get()
      .join('\t')
    copiedText += rowData + '\n'
  })

  if (copiedText) {
    let textarea = $('<textarea>').val(copiedText).appendTo('body').select()
    document.execCommand('copy')
    textarea.remove()
  } else {
    alert('No rows selected!')
  }
}

// Load lại dữ liệu và render
function loadAndRender(worksheet) {
  // Lấy dữ liệu summary từ worksheet
  worksheet.getSummaryDataAsync().then(function (sumData) {
    let columns = sumData.columns.map((col) => col.fieldName)
    let data = sumData.data

    // Detect tree_l1, tree_l2,... để biết có tree view
    const treeCols = columns.filter((col) => /^tree_l\d+$/i.test(col))
    treeCols.sort((a, b) => {
      const getLevel = (s) => parseInt(s.match(/\d+/)[0])
      return getLevel(a) - getLevel(b)
    })

    // Detect Measure Names / Measure Values
    const measureNameIndex = columns.indexOf('Measure Names')
    const measureValueIndex = columns.indexOf('Measure Values')

    // Base valid (dimension) columns (loại bỏ AGG, hidden, Measure Name/Value)
    const baseValidCols = columns.filter(
      (col, idx) =>
        !col.includes('AGG') &&
        !col.startsWith('hiden') &&
        idx !== measureNameIndex &&
        idx !== measureValueIndex
    )

    // Nếu có measure pivot → build list measureCols
    let measureCols = []
    if (measureNameIndex !== -1 && measureValueIndex !== -1) {
      measureCols = [
        ...new Set(data.map((row) => row[measureNameIndex].formattedValue))
      ]
    }

    // === RENDER TREE VIEW ===
    if (treeCols.length > 0) {
      let dimCols = baseValidCols.filter((c) => !treeCols.includes(c))
      let valueCols = measureCols.length > 0 ? measureCols : []

      // Build nodeList tree từ data
      let nodeList = []
      let nodeMap = {}

      data.forEach((row) => {
        // Lấy path từ tree_l1 → tree_ln
        let fullPath = []
        treeCols.forEach((col) => {
          let val = row[columns.indexOf(col)].formattedValue
          if (val && `${val}`.trim() !== '') {
            fullPath.push(val)
          }
        })
        if (fullPath.length === 0) return

        // Tạo node cho từng cấp trong path
        fullPath.forEach((label, idx) => {
          let nodeId = fullPath.slice(0, idx + 1).join('|')
          let parentId = idx === 0 ? null : fullPath.slice(0, idx).join('|')

          if (!nodeMap[nodeId]) {
            nodeMap[nodeId] = {
              id: nodeId,
              parent: parentId,
              label: label,
              level: idx + 1,
              isLeaf: idx === fullPath.length - 1,
              dimValues: {},
              measures: {}
            }
            nodeList.push(nodeMap[nodeId])
          }

          // Nếu là node lá → attach dim & measure
          if (idx === fullPath.length - 1) {
            const n = nodeMap[nodeId]
            dimCols.forEach((colName) => {
              n.dimValues[colName] =
                row[columns.indexOf(colName)].formattedValue
            })
            if (measureCols.length > 0) {
              const mName = row[measureNameIndex].formattedValue
              const mVal = row[measureValueIndex].formattedValue
              if (mName) {
                n.measures[mName] = mVal
              }
              valueCols.forEach((m) => {
                if (n.measures[m] === undefined) n.measures[m] = ''
              })
            }
          }
        })
      })

      // Render headers: Tree + dimCols + measureCols
      addHeaderAndFilterCells(['Tree'], (h, idx) => ({
        type: 'button',
        coltype: 'tree',
        idx: 0
      }))
      addHeaderAndFilterCells(dimCols, (h, idx) => ({
        type: 'button',
        coltype: 'dim',
        idx: idx
      }))
      addHeaderAndFilterCells(valueCols, (h, idx) => ({
        type: 'button',
        coltype: 'measure',
        idx: idx
      }))

      // Render body rows từ nodeList
      nodeList.forEach((node) => {
        let indent = (node.level - 1) * 20
        let toggleBtn = node.isLeaf
          ? ''
          : `<span class="toggle-btn">[+]</span> `
        let attrs = node.parent
          ? `data-parent-id="${node.parent}" style="display:none"`
          : ''
        let rowHTML = `<tr data-node-id="${node.id}" ${attrs}>`
        rowHTML += `<td style="padding-left:${indent}px">${toggleBtn}${node.label}</td>`
        dimCols.forEach((col) => {
          rowHTML += `<td>${node.dimValues[col] || ''}</td>`
        })
        valueCols.forEach((col) => {
          rowHTML += `<td style="text-align:right">${
            node.measures[col] || ''
          }</td>`
        })
        rowHTML += `</tr>`
        $('#table-body').append(rowHTML)
      })

      // Render total row
      if (valueCols.length > 0) {
        const totals = calculateTotals([], valueCols, columns, true, nodeList)
        addTotalRow(valueCols, totals, [], true, dimCols)
      }

      expandAll()

      // Handler expand/collapse [+]/[-]
      $(document).on('click', '.toggle-btn', function () {
        const $btn = $(this)
        const $row = $btn.closest('tr')
        const nodeId = $row.data('node-id')
        const isExpanded = $row.hasClass('expanded')
        if (isExpanded) {
          collapseChildren(nodeId)
          $btn.text('[+]')
          $row.removeClass('expanded')
        } else {
          expandChildren(nodeId)
          $btn.text('[−]')
          $row.addClass('expanded')
        }

        table.columns.adjust().draw(false)
      })

      // Handler filter button (tree/dim/measure)
      $(document).on('click', '.show-filter-btn', function () {
        let btn = $(this)
        let colType = btn.data('coltype')
        let idx = parseInt(btn.data('idx'))

        if (colType === 'tree') {
          const unique = [...new Set(nodeList.map((n) => n.label))]
          let select = `<select class="column-filter" id="filter-0" onchange="filterColumn(0)">`
          select += `<option value="">All Tree</option>`
          unique.forEach(
            (v) => (select += `<option value="${v}">${v}</option>`)
          )
          select += `</select></div>`
          btn.closest('th').html(select)
          // Cập nhật lại layout
          table.columns.adjust().draw(false)

          // Làm mới fixedHeader
          table.fixedHeader.adjust()
        } else if (colType === 'dim') {
          const tableColIdx = 1 + idx
          const dName = dimCols[idx]
          const unique = [...new Set(nodeList.map((n) => n.dimValues[dName]))]
          let select = `<select class="column-filter" id="filter-${tableColIdx}" onchange="filterColumn(${tableColIdx})">`
          select += `<option value="">All ${dName}</option>`
          unique.forEach(
            (v) => (select += `<option value="${v}">${v}</option>`)
          )
          select += `</select></div>`
          btn.closest('th').html(select)
          // Cập nhật lại layout
          table.columns.adjust().draw(false)

          // Làm mới fixedHeader
          table.fixedHeader.adjust()
        } else if (colType === 'measure') {
          const tableColIdx = 1 + dimCols.length + idx
          const mName = valueCols[idx]
          const unique = [...new Set(nodeList.map((n) => n.measures[mName]))]
          let select = `<select class="column-filter" id="filter-${tableColIdx}" onchange="filterColumn(${tableColIdx})">`
          select += `<option value="">All ${mName}</option>`
          unique.forEach(
            (v) => (select += `<option value="${v}">${v}</option>`)
          )
          select += `</select></div>`
          btn.closest('th').html(select)
          // Cập nhật lại layout
          table.columns.adjust().draw(false)

          // Làm mới fixedHeader
          table.fixedHeader.adjust()
        }
      })
    }

    // === CẤU HÌNH DATATABLES CHUNG ===
    $.fn.dataTable.ext.type.search.string = function (data) {
      return !data ? '' : normalizeUnicode(data.toString())
    }

    $.fn.dataTable.ext.search.push(function (settings, searchData) {
      var searchTerm = normalizeUnicode(settings.oPreviousSearch.sSearch)
      if (searchTerm === '') return true
      return searchData.some((cell) =>
        normalizeUnicode(cell.toString()).includes(searchTerm)
      )
    })

    // Init DataTable
    let table = $('#data-table').DataTable({
      paging: true,
      searching: true,
      ordering: false,
      pageLength: 100,
      scrollX: true,
      scrollY: 'calc(100vh - 160px)',
      columnDefs: [
        {
          targets: 0, // cột tree đầu tiên
          width: '200px', // cố định width
          className: 'tree-column'
        }
      ],
      dom: '<"top-controls"lBf>rtip',
      fixedHeader: {
        header: true,
        headerOffset: $('.fixed-controls').outerHeight() || 50
      },
      lengthMenu: [
        [10, 50, 100, 500, 1000, 2000, 5000],
        [10, 50, 100, 500, 1000, 2000, 5000]
      ],
      buttons: [
        {
          extend: 'excelHtml5',
          text: 'Export to Excel',
          title: 'Exported_Data'
        }
      ],
      footerCallback: function () {
        // Giữ total row ở cuối sau khi filter
        $('.total-row').appendTo(this.api().table().body())
      }
    })

    // === GẮN CONTROL PHỤ ===
    $('#table-length').html($('.dataTables_length'))
    $('#table-search').html($('.dataTables_filter'))
    $('#table-export').html($('.dt-buttons'))

    // === Filter function (áp dụng cho input/select) ===
    window.filterColumn = function (index) {
      let val = $(`#filter-${index}`).val()
      let searchVal = val ? normalizeUnicode(val) : ''
      table.column(index).search(searchVal, true, false).draw()
    }

    // === Row selection (Ctrl, Shift, Click) ===
    let lastSelectedRow = null
    $('#table-body').on('click', 'tr', function (event) {
      if ($(this).hasClass('total-row')) return
      if (event.ctrlKey) {
        $(this).toggleClass('highlight')
      } else if (event.shiftKey && lastSelectedRow) {
        let rows = $('#table-body tr:not(.total-row)')
        let start = rows.index(lastSelectedRow)
        let end = rows.index(this)
        let [min, max] = [Math.min(start, end), Math.max(start, end)]
        rows.slice(min, max + 1).addClass('highlight')
      } else {
        $('#table-body tr:not(.total-row)').removeClass('highlight')
        $(this).addClass('highlight')
      }
      lastSelectedRow = this
    })

    // === Copy bằng Ctrl+C ===
    $(document).on('keyup', function (event) {
      if (event.ctrlKey && (event.key === 'c' || event.key === 'C')) {
        copySelectedRows()
      }
    })
    $('#copy-btn').on('click', function () {
      copySelectedRows()
    })

    // === Context menu (chuột phải → Copy) ===
    let contextMenu = $(
      '<ul id="context-menu" class="context-menu"><li id="copy-selected">Copy</li></ul>'
    )
    $('body').append(contextMenu)
    $(document).on('click', function () {
      $('#context-menu').hide()
    })
    $('#table-body').on(
      'contextmenu',
      'tr.highlight:not(.total-row)',
      function (event) {
        event.preventDefault()
        $('#context-menu')
          .css({ top: event.pageY + 'px', left: event.pageX + 'px' })
          .show()
      }
    )
    $('#copy-selected').on('click', function () {
      copySelectedRows()
      $('#context-menu').hide()
    })
  })
}

// === MAIN ENTRY: khi document ready ===
document.addEventListener('DOMContentLoaded', () => {
  tableau.extensions.initializeAsync().then(() => {
    let worksheet = tableau.extensions.dashboardContent.dashboard.worksheets[0]

    // Load lần đầu
    loadAndRender(worksheet)

    // Lắng nghe filter và parameter change
    worksheet.addEventListener(tableau.TableauEventType.FilterChanged, () => {
      loadAndRender(worksheet)
    })

    tableau.extensions.dashboardContent.dashboard
      .getParametersAsync()
      .then(function (parameters) {
        parameters.forEach(function (p) {
          p.addEventListener(tableau.TableauEventType.ParameterChanged, () =>
            loadAndRender(worksheet)
          )
        })
      })
  })
})
